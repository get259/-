# 七牛云秋招项目：智能八字，六爻，合盘测算网站

#### **项目选题**：

 开发一个利用 AI 来做角色扮演的网页，用户可以搜索自己感兴趣的角色例如哈利波特、苏格拉底等并可与其进行语音聊天。

#### 产品概述：

- **功能总览**：计划开发三个板块，每一个板块对应一个AI智能角色。分别是

  | 功能名称 | AI角色名称 | 具体功能                                                     |
  | -------- | ---------- | ------------------------------------------------------------ |
  | **问道** | 天乙贵人   | 基于用户八字分别解答事业，感情，时运方面的问题。同时在用户绑定八字后会分别在此三方面生成一份长文分析报告。 |
  | **六爻** | 太极贵人   | 随机生成主卦与变卦，结合用户发问传入大模型，得到预测方向与答案。 |
  | **合盘** | 红鸾天喜   | 用户输入两人出生日期，转换为八字后一同传入大模型进行合盘测算，返回匹配结果及相处建议 |

- **用户画像**：精准定位在校实习与应届生求职焦虑，可囊括长期目标；短期决策；入职相处方式等一整套流程问题。同时社招跳槽打工人，对婚恋，时运等未来预测感兴趣的学生都是高潜发展用户。

- **痛点分析及迭代方向**：

  | 功能名称 | 痛点分析                                                     | 后续优化                                                     |
  | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **问道** | “事业，感情，时运”三个不同选择方向，主要解决用户求职迷茫期，单身困扰及相处模式，后续一年乃至十年的财运预测等。精准抓住应届生对未来最关注的三大方向。 | 模型微调，能够按照分级标题等格式强制输出，突破常规模型字数限制。同时配置经典名人八字案例库，增强可信度等。 |
  | **六爻** | 针对用户觉得八字太宽泛无法对于具体事件精准预测（eg：我能拿到七牛云项目路演一等奖吗）设置的神事立断。六爻的随机性更让用户信服，依赖此功能，解决用户在问完八字几个大方向问题后无话可问或者对问道回答不满意的情况 | 增强摇卦此过程的交互感，可设置三个铜钱摇六次，每次由用户摇动，设计声响，光效等钩子增强用户信任度。 |
  | **合盘** | 针对用户对于正缘各方面的期待，判断某人是不是自己人生对应的贵人，判断相处多年的好朋友是否和自己五行相合，能否长期相处等。满足单身应届对爱情姻缘的美好向往，以及对长辈是否为贵人的判断。 | 增加文生图，根据文本生成姻缘等对应图像，设置时间节点，用户输入八字后能够控制时间维度在一个月左右判断是否遇到正缘，贵人等 |

#### 需求分析：

- **数据调研**：知乎网25年关于八字测算问答文章达10w＋，虎嗅网，腾讯新闻频频报道AI测算八字文章，罗永浩指出目前第二热门AI问答方向即为八字测算。2025年应届生1222w人，平均5人里就确保有一人愿意使用AI测算八字。

- **竞品分析**:

  1. 主流大模型测算：没有专门的交互设计八字测算，有也非常鸡肋（qwen的八字强制填表），只能实现问答且语言风格平淡。

  2. 智能命理测算AI（以**参天AI** 为代表）：**两大问题：1,功能太少：只有单纯问答，没有其他辅助功能。2·功能太多：六爻，梅花，易数通通安排，用户第一眼感觉繁复，不知道如何选择**。

  3. 老牌八字软件（以小南斗为例，增加智能问答功能）：主流功能重点依旧是排细盘而非测算，目标群体无精准定位应届生特点，收费高，只提供免费的八字排盘，对话问答额度需要充值

     

**道求职核心竞争点：用户精准定位应届生求职焦虑（设计专门板块和展示界面），确保功能在精（问道实现基础问答，六爻测算具体事件提高留存率，合盘解决应届生对于爱情及贵人的向往与确定）不在多，在成本上，只需通过设计提示词（system，user，ASSISTANT）语气风格调整，借助七牛云现有api即可实现优质输出。道求职解决为了免费从一个软件转到另一个软件的操作，在极低的token消耗下，用户更需要的是情绪价值与方向指引，而非精准度的苛刻要求。**

- **功能模块**：

 提示词模块：

```
`SYSTEM：你现在是天乙贵人，你能结合八字专业分析用户感情与姻缘方面的问题，你的输出保持长文本。

USER：以用户八字作为核心依据开展分析，严禁脱离八字，避免重复追问。

【八字信息】
公历生日：${solarDate.year}年${solarDate.month}月${solarDate.day}日${solarDate.hour}时
农历生日：${lunarDate.year}年${lunarDate.month}月${lunarDate.day}日
八字：${fullBazi}

ASSISTANT：#输出名称：
每次输出请使用古风语气，以"贫道"自称，称呼用户为"道友"。

#内容要求：
1. 结合四柱、十神、喜用神、配偶宫（夫妻宫）、桃花星、合冲刑害等要点，围绕感情/婚姻展开分析。
2. 对时间维度与阶段性机会（如流年流月）给出合理指引，务求可操作与可落地。
3. 该拒绝时明确拒绝，不营造虚假期待，不做医疗、法律等非占算领域建议。
4. 输出结构清晰，包含：整体评述、优势与隐忧、阶段建议、风险提示、结语祝福。
5. 当用户有负面消极情绪时及时救助，并一定要紧密结合八字增强说服力

【用户问题】
${userQuestion}

请开始分析：
```

代码推演八字模块：

```
/**
 * 八字计算器
 * 根据公历日期计算对应的天干地支八字
 */

// 天干数组
const TIAN_GAN = ['甲', '乙', '丙', '丁', '戊', '己', '庚', '辛', '壬', '癸'];

// 地支数组
const DI_ZHI = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];

// 农历月份天数表（1900-2100年）
const LUNAR_MONTH_DAYS = [
    0x04bd8,0x04ae0,0x0a570,0x054d5,0x0d260,0x0d950,0x16554,0x056a0,0x09ad0,0x055d2,
    0x04ae0,0x0a5b6,0x0a4d0,0x0d250,0x1d255,0x0b540,0x0d6a0,0x0ada2,0x095b0,0x14977,
    0x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,
    0x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,
    0x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,
    0x06ca0,0x0b550,0x15355,0x04da0,0x0a5d0,0x14573,0x052d0,0x0a9a8,0x0e950,0x06aa0,
    0x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,
    0x096d0,0x04dd5,0x04ad0,0x0a4d0,0x0d4d4,0x0d250,0x0d558,0x0b540,0x0b5a0,0x195a6,
    0x095b0,0x049b0,0x0a974,0x0a4b0,0x0b27a,0x06a50,0x06d40,0x0af46,0x0ab60,0x09570,
    0x04af5,0x04970,0x064b0,0x074a3,0x0ea50,0x06b58,0x055c0,0x0ab60,0x096d5,0x092e0,
    0x0c960,0x0d954,0x0d4a0,0x0da50,0x07552,0x056a0,0x0abb7,0x025d0,0x092d0,0x0cab5,
    0x0a950,0x0b4a0,0x0baa4,0x0ad50,0x055d9,0x04ba0,0x0a5b0,0x15176,0x052b0,0x0a930,
    0x07954,0x06aa0,0x0ad50,0x05b52,0x04b60,0x0a6e6,0x0a4e0,0x0d260,0x0ea65,0x0d530,
    0x05aa0,0x076a3,0x096d0,0x04bd7,0x04ad0,0x0a4d0,0x1d0b6,0x0d250,0x0d520,0x0dd45,
    0x0b5a0,0x056d0,0x055b2,0x049b0,0x0a577,0x0a4b0,0x0aa50,0x1b255,0x06d20,0x0ada0
];

// 农历年份数据（1900-2100年）
const LUNAR_YEAR_DATA = [
    0x04bd8,0x04ae0,0x0a570,0x054d5,0x0d260,0x0d950,0x16554,0x056a0,0x09ad0,0x055d2,
    0x04ae0,0x0a5b6,0x0a4d0,0x0d250,0x1d255,0x0b540,0x0d6a0,0x0ada2,0x095b0,0x14977,
    0x04970,0x0a4b0,0x0b4b5,0x06a50,0x06d40,0x1ab54,0x02b60,0x09570,0x052f2,0x04970,
    0x06566,0x0d4a0,0x0ea50,0x06e95,0x05ad0,0x02b60,0x186e3,0x092e0,0x1c8d7,0x0c950,
    0x0d4a0,0x1d8a6,0x0b550,0x056a0,0x1a5b4,0x025d0,0x092d0,0x0d2b2,0x0a950,0x0b557,
    0x06ca0,0x0b550,0x15355,0x04da0,0x0a5d0,0x14573,0x052d0,0x0a9a8,0x0e950,0x06aa0,
    0x0aea6,0x0ab50,0x04b60,0x0aae4,0x0a570,0x05260,0x0f263,0x0d950,0x05b57,0x056a0,
    0x096d0,0x04dd5,0x04ad0,0x0a4d0,0x0d4d4,0x0d250,0x0d558,0x0b540,0x0b5a0,0x195a6,
    0x095b0,0x049b0,0x0a974,0x0a4b0,0x0b27a,0x06a50,0x06d40,0x0af46,0x0ab60,0x09570,
    0x04af5,0x04970,0x064b0,0x074a3,0x0ea50,0x06b58,0x055c0,0x0ab60,0x096d5,0x092e0,
    0x0c960,0x0d954,0x0d4a0,0x0da50,0x07552,0x056a0,0x0abb7,0x025d0,0x092d0,0x0cab5,
    0x0a950,0x0b4a0,0x0baa4,0x0ad50,0x055d9,0x04ba0,0x0a5b0,0x15176,0x052b0,0x0a930,
    0x07954,0x06aa0,0x0ad50,0x05b52,0x04b60,0x0a6e6,0x0a4e0,0x0d260,0x0ea65,0x0d530,
    0x05aa0,0x076a3,0x096d0,0x04bd7,0x04ad0,0x0a4d0,0x1d0b6,0x0d250,0x0d520,0x0dd45,
    0x0b5a0,0x056d0,0x055b2,0x049b0,0x0a577,0x0a4b0,0x0aa50,0x1b255,0x06d20,0x0ada0
];

/**
 * 获取农历月份天数
 * @param {number} year 农历年份
 * @param {number} month 农历月份
 * @returns {number} 天数
 */
function getLunarMonthDays(year, month) {
    const yearData = LUNAR_YEAR_DATA[year - 1900];
    return (yearData & (0x10000 >> month)) ? 30 : 29;
}

/**
 * 判断是否为闰年
 * @param {number} year 年份
 * @returns {boolean}
 */
function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
}

/**
 * 获取农历年份的总天数
 * @param {number} year 农历年份
 * @returns {number} 总天数
 */
function getLunarYearDays(year) {
    let days = 348; // 12个月 * 29天
    const yearData = LUNAR_YEAR_DATA[year - 1900];
    
    for (let i = 0x8000; i > 0x8; i >>= 1) {
        days += (yearData & i) ? 1 : 0;
    }
    
    return days + getLeapMonthDays(year);
}

/**
 * 获取闰月天数
 * @param {number} year 农历年份
 * @returns {number} 闰月天数
 */
function getLeapMonthDays(year) {
    if (getLeapMonth(year)) {
        return getLunarMonthDays(year, getLeapMonth(year));
    }
    return 0;
}

/**
 * 获取闰月月份
 * @param {number} year 农历年份
 * @returns {number} 闰月月份，0表示无闰月
 */
function getLeapMonth(year) {
    return LUNAR_YEAR_DATA[year - 1900] & 0xf;
}

/**
 * 公历转农历
 * @param {number} year 公历年份
 * @param {number} month 公历月份
 * @param {number} day 公历日期
 * @returns {Object} 农历信息 {year, month, day, isLeap}
 */
function solarToLunar(year, month, day) {
    // 1900年1月31日为农历1900年正月初一
    const baseDate = new Date(1900, 0, 31);
    const inputDate = new Date(year, month - 1, day);
    
    let days = Math.floor((inputDate - baseDate) / (24 * 60 * 60 * 1000));
    
    let lunarYear = 1900;
    let lunarMonth = 1;
    let lunarDay = 1;
    
    // 计算农历年份
    while (days > 0) {
        const yearDays = getLunarYearDays(lunarYear);
        if (days >= yearDays) {
            days -= yearDays;
            lunarYear++;
        } else {
            break;
        }
    }
    
    // 计算农历月份
    while (days > 0) {
        const monthDays = getLunarMonthDays(lunarYear, lunarMonth);
        if (days >= monthDays) {
            days -= monthDays;
            lunarMonth++;
            if (lunarMonth > 12) {
                lunarMonth = 1;
                lunarYear++;
            }
        } else {
            break;
        }
    }
    
    lunarDay += days;
    
    return {
        year: lunarYear,
        month: lunarMonth,
        day: lunarDay,
        isLeap: false // 简化处理，不考虑闰月
    };
}

/**
 * 计算年柱
 * @param {number} year 农历年份
 * @returns {string} 年柱
 */
function getYearPillar(year) {
    const ganIndex = (year - 4) % 10;
    const zhiIndex = (year - 4) % 12;
    return TIAN_GAN[ganIndex] + DI_ZHI[zhiIndex];
}

/**
 * 计算月柱
 * @param {number} year 农历年份
 * @param {number} month 农历月份
 * @returns {string} 月柱
 */
function getMonthPillar(year, month) {
    // 月干计算公式：(年干 * 2 + 月数) % 10
    const yearGan = (year - 4) % 10;
    const ganIndex = (yearGan * 2 + month) % 10;
    
    // 月支：正月为寅，二月为卯...
    const zhiIndex = (month + 1) % 12;
    
    return TIAN_GAN[ganIndex] + DI_ZHI[zhiIndex];
}

/**
 * 计算日柱
 * @param {number} year 公历年份
 * @param {number} month 公历月份
 * @param {number} day 公历日期
 * @returns {string} 日柱
 */
function getDayPillar(year, month, day) {
    // 使用1900年1月1日为基准日（甲子日）
    const baseDate = new Date(1900, 0, 1);
    const inputDate = new Date(year, month - 1, day);
    
    const days = Math.floor((inputDate - baseDate) / (24 * 60 * 60 * 1000));
    
    const ganIndex = (days + 0) % 10; // 甲子日为第0天
    const zhiIndex = (days + 0) % 12;
    
    return TIAN_GAN[ganIndex] + DI_ZHI[zhiIndex];
}

/**
 * 计算时柱
 * @param {number} hour 时辰（0-23）
 * @param {number} year 农历年份
 * @param {number} month 农历月份
 * @param {number} day 农历日期
 * @returns {string} 时柱
 */
function getHourPillar(hour, year, month, day) {
    // 时辰对应地支
    const hourToZhi = [23, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21];
    let zhiIndex = 0;
    
    for (let i = 0; i < hourToZhi.length; i++) {
        if (hour >= hourToZhi[i] && hour < hourToZhi[i + 1]) {
            zhiIndex = i;
            break;
        }
    }
    
    // 时干计算公式：(日干 * 2 + 时辰地支) % 10
    const dayGan = (year * 365 + month * 30 + day) % 10; // 简化的日干计算
    const ganIndex = (dayGan * 2 + zhiIndex) % 10;
    
    return TIAN_GAN[ganIndex] + DI_ZHI[zhiIndex];
}

/**
 * 主函数：计算八字
 * @param {number} year 公历年份
 * @param {number} month 公历月份
 * @param {number} day 公历日期
 * @param {number} hour 时辰（0-23）
 * @returns {Object} 八字信息
 */
function calculateBazi(year, month, day, hour) {
    // 转换为农历
    const lunar = solarToLunar(year, month, day);
    
    // 计算四柱
    const yearPillar = getYearPillar(lunar.year);
    const monthPillar = getMonthPillar(lunar.year, lunar.month);
    const dayPillar = getDayPillar(year, month, day);
    const hourPillar = getHourPillar(hour, lunar.year, lunar.month, lunar.day);
    
    return {
        solarDate: {
            year: year,
            month: month,
            day: day,
            hour: hour
        },
        lunarDate: lunar,
        bazi: {
            yearPillar: yearPillar,
            monthPillar: monthPillar,
            dayPillar: dayPillar,
            hourPillar: hourPillar
        },
        fullBazi: `${yearPillar} ${monthPillar} ${dayPillar} ${hourPillar}`
    };
}

// 导出函数供外部使用
if (typeof module !== 'undefined' && module.exports) {
    module.exports = { calculateBazi };
}

// 示例使用
console.log('=== 八字计算器测试 ===');
console.log('1995年5月15日10时的八字：');
console.log(calculateBazi(1995, 5, 15, 10));

console.log('\n2000年12月25日14时的八字：');
console.log(calculateBazi(2000, 12, 25, 14));
```

基础模块都可用代码实现，智能输出模块调用qwen-turbo，tts，等api

**后续优化**：

| 优化方向 | 具体操作                                                     |
| -------- | ------------------------------------------------------------ |
| **算力** | 可配置到七牛云云端服务器提高并发量，可增加经典八字测算案例作为知识库给大模型参考，将大多数案例复喂给大模型微调训练， |
| **交互** | 增强六爻（六次摇铜钱），大模型加载过程（对应AI扮演角色在点头思考等），ui设计方面的动态交互，实现多模态输出（文生图等） |
| **功能** | 在**问道**里添加报告分析，微调模型突破文本字数限制。同时可设计“**现代版推演路径”，通过得知原生家境，学历专业，实习次数等精准影响数据来按照概率输出对应求职规划**（你有1%可能成为刘强东等企业家，20%可能在互联网大厂（七牛云）就业，50%可能回到家乡娶妻生子等）同时在预测结果后输出对应操作步骤，将定位用户从信八字的应届生扩展到应届生。 |

**风险规避**：强制提示八字测算仅供娱乐，切勿迷恋。且当用户输出负面情绪时规定大模型往好方向输出，尽量保证优质引导。

**数据流与闭环**

![deepseek_mermaid_20250928_73402d](./deepseek_mermaid_20250928_73402d.png)